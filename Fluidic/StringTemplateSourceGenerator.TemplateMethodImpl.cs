using System;
using System.CodeDom.Compiler;
using System.Linq;
using Fluidic.Extensions;
using Scriban.Parsing;

namespace Fluidic;

public sealed partial class StringTemplateSourceGenerator
{
    private static void WriteTemplateMethod(IndentedTextWriter writer, TemplateMethodDetails model)
    {
        WriteNamespaceParts(writer, model);

        writer.WriteLine();

        writer.Write("public static partial class ");
        writer.Write(model.ClassName);
        writer.WriteLine();

        writer.WriteLine("{");
        using (writer.Indent())
        {
            writer.Write("public static partial void ");
            writer.Write(model.MethodDetails.Name);
            writer.Write("(this ");
            for (var index = 0; index < model.MethodDetails.MethodSymbol.Parameters.Length; index++)
            {
                var parameter = model.MethodDetails.MethodSymbol.Parameters[index];
                writer.Write(parameter.Type.Name);
                writer.Write(" ");
                writer.Write(parameter.Name);

                if (index < model.MethodDetails.MethodSymbol.Parameters.Length - 1)
                {
                    writer.Write(", ");
                }
            }

            writer.WriteLine(")");

            writer.WriteLine("{");
            using (writer.Indent())
            {
                WriteTokens(writer, model);
            }
            writer.WriteLine("}");
        }
        writer.WriteLine("}");
    }

    private static void WriteTokens(IndentedTextWriter writer, TemplateMethodDetails model)
    {
        var template = model.AttributeDetails.Template;

        if (template is null)
        {
            return;
        }

        var totalTokens = model.AttributeDetails.Tokens.Count;
        for (var i = 0; i < totalTokens; i++)
        {
            var token = model.AttributeDetails.Tokens[i];

            switch (token.Type)
            {
                case TokenType.Raw:
                    var rawText = template.Substring(
                        token.Start.Offset,
                        length: token.End.Offset - token.Start.Offset + 1
                    );

                    writer.Write("builder.Append(@\"");
                    writer.Write(rawText);
                    writer.WriteLine("\");");

                    break;
                case TokenType.CodeEnter:
                    var position = token.End.Offset + 1;

                    // capture any potential identifiers
                    var peekNextToken = model.AttributeDetails.Tokens[i + 1];

                    string? identifier = null;
                    if (peekNextToken.Type == TokenType.Identifier)
                    {
                        identifier = template.Substring(
                            peekNextToken.Start.Offset,
                            length: peekNextToken.End.Offset - peekNextToken.Start.Offset + 1
                        );
                    }

                    while (token.Type != TokenType.CodeExit)
                    {
                        token = model.AttributeDetails.Tokens[++i];
                    }

                    switch (identifier)
                    {
                        case "if":
                            var ifTokenPosition = peekNextToken.End.Offset + 1;
                            writer.Write("if (");
                            writer.Write(
                                template.Substring(
                                    ifTokenPosition,
                                    token.Start.Offset - ifTokenPosition
                                )
                            );
                            writer.WriteLine(")");
                            writer.WriteLine("{");
                            writer.Indent++;
                            break;
                        case "end":
                            writer.Indent--;
                            writer.WriteLine("}");
                            break;
                        default:
                            writer.Write("builder.Append(");
                            writer.Write(
                                template.Substring(position, length: token.Start.Offset - position)
                            );
                            writer.WriteLine(");");
                            break;
                    }

                    break;
                default:
                    continue;
            }
        }
    }

    private static void WriteNamespaceParts(IndentedTextWriter writer, TemplateMethodDetails model)
    {
        writer.WriteLine("// <auto-generated/>");
        writer.WriteLine("#nullable enable");
        writer.WriteLine();

        foreach (
            var usingDirective in model
                .Usings.Select(u => u.ToString())
                .Distinct()
                .OrderBy(u => u, StringComparer.Ordinal)
        )
        {
            writer.WriteLine(usingDirective);
        }

        writer.WriteLine();
        writer.Write("namespace ");
        writer.Write(model.Namespace);
        writer.WriteLine(";");
    }
}
